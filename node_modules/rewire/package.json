{
  "_args": [
    [
      {
        "raw": "rewire",
        "scope": null,
        "escapedName": "rewire",
        "name": "rewire",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/home/tonio/Documentos/Developer/Proyectos/Personales/NodeJS/MakingCMS"
    ]
  ],
  "_from": "rewire@latest",
  "_id": "rewire@3.0.2",
  "_inCache": true,
  "_location": "/rewire",
  "_nodeVersion": "8.9.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/rewire-3.0.2.tgz_1511190039872_0.22571709007024765"
  },
  "_npmUser": {
    "name": "jhnns",
    "email": "mail@johannesewald.de"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "rewire",
    "scope": null,
    "escapedName": "rewire",
    "name": "rewire",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#DEV:/",
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/rewire/-/rewire-3.0.2.tgz",
  "_shasum": "25e5413c4f1676eb3247d1884198b3a265408bbd",
  "_shrinkwrap": null,
  "_spec": "rewire",
  "_where": "/home/tonio/Documentos/Developer/Proyectos/Personales/NodeJS/MakingCMS",
  "author": {
    "name": "Johannes Ewald",
    "email": "mail@johannesewald.de"
  },
  "bugs": {
    "url": "https://github.com/jhnns/rewire/issues",
    "email": "mail@johannesewald.de"
  },
  "dependencies": {
    "babel-core": "^6.26.0",
    "babel-plugin-transform-es2015-block-scoping": "^6.26.0"
  },
  "description": "Easy dependency injection for node.js unit testing",
  "devDependencies": {
    "coffee-script": "^1.8.0",
    "expect.js": "^0.3.1",
    "mocha": "^4.0.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-ejkkt3qYnsQ38ifc9llAAzuHiGM7kR8N5/mL3aHWgmWwet0OMFcmJB8aTsMV2PBHCWxNVTLCeRfBpEa8X2+1fw==",
    "shasum": "25e5413c4f1676eb3247d1884198b3a265408bbd",
    "tarball": "https://registry.npmjs.org/rewire/-/rewire-3.0.2.tgz"
  },
  "gitHead": "18c5d0e09ef0f6cf666d664fbbf74435e190f23c",
  "homepage": "https://github.com/jhnns/rewire",
  "keywords": [
    "dependency",
    "injection",
    "mock",
    "shim",
    "module",
    "unit",
    "test",
    "leak",
    "inspect",
    "fake",
    "require"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "maintainers": [
    {
      "name": "jhnns",
      "email": "mail@johannesewald.de"
    },
    {
      "name": "peerigon",
      "email": "developers@peerigon.com"
    }
  ],
  "name": "rewire",
  "optionalDependencies": {},
  "readme": "rewire\r\n======\r\n**Easy monkey-patching for node.js unit tests**\r\n\r\n[![](https://img.shields.io/npm/v/rewire.svg)](https://www.npmjs.com/package/rewire)\r\n[![](https://img.shields.io/npm/dm/rewire.svg)](https://www.npmjs.com/package/rewire)\r\n[![Dependency Status](https://david-dm.org/jhnns/rewire.svg)](https://david-dm.org/jhnns/rewire)\r\n[![Build Status](https://travis-ci.org/jhnns/rewire.svg?branch=master)](https://travis-ci.org/rewire/jhnns)\r\n[![Coverage Status](https://img.shields.io/coveralls/jhnns/rewire.svg)](https://coveralls.io/r/jhnns/rewire?branch=master)\r\n\r\nrewire adds a special setter and getter to modules so you can modify their behaviour for better unit testing. You may\r\n\r\n- inject mocks for other modules or globals like `process`\r\n- inspect private variables\r\n- override variables within the module.\r\n\r\n**Please note:** The current version of rewire is only compatible with CommonJS modules. See [Limitations](https://github.com/jhnns/rewire#limitations).\r\n\r\n<br>\r\n\r\nInstallation\r\n------------\r\n\r\n`npm install rewire`\r\n\r\n<br />\r\n\r\nIntroduction\r\n------------\r\n\r\nImagine you want to test this module:\r\n\r\n```javascript\r\n// lib/myModules.js\r\n// With rewire you can change all these variables\r\nvar fs = require(\"fs\"),\r\n    path = \"/somewhere/on/the/disk\";\r\n\r\nfunction readSomethingFromFileSystem(cb) {\r\n    console.log(\"Reading from file system ...\");\r\n    fs.readFile(path, \"utf8\", cb);\r\n}\r\n\r\nexports.readSomethingFromFileSystem = readSomethingFromFileSystem;\r\n```\r\n\r\nNow within your test module:\r\n\r\n```javascript\r\n// test/myModule.test.js\r\nvar rewire = require(\"rewire\");\r\n\r\nvar myModule = rewire(\"../lib/myModule.js\");\r\n```\r\n\r\nrewire acts exactly like require. With just one difference: Your module will now export a special setter and getter for private variables.\r\n\r\n```javascript\r\nmyModule.__set__(\"path\", \"/dev/null\");\r\nmyModule.__get__(\"path\"); // = '/dev/null'\r\n```\r\n\r\nThis allows you to mock everything in the top-level scope of the module, like the fs module for example. Just pass the variable name as first parameter and your mock as second.\r\n\r\n```javascript\r\nvar fsMock = {\r\n    readFile: function (path, encoding, cb) {\r\n        expect(path).to.equal(\"/somewhere/on/the/disk\");\r\n        cb(null, \"Success!\");\r\n    }\r\n};\r\nmyModule.__set__(\"fs\", fsMock);\r\n\r\nmyModule.readSomethingFromFileSystem(function (err, data) {\r\n    console.log(data); // = Success!\r\n});\r\n```\r\n\r\nYou can also set multiple variables with one call.\r\n\r\n```javascript\r\nmyModule.__set__({\r\n    fs: fsMock,\r\n    path: \"/dev/null\"\r\n});\r\n```\r\n\r\nYou may also override globals. These changes are only within the module, so you don't have to be concerned that other modules are influenced by your mock.\r\n\r\n```javascript\r\nmyModule.__set__({\r\n    console: {\r\n        log: function () { /* be quiet */ }\r\n    },\r\n    process: {\r\n        argv: [\"testArg1\", \"testArg2\"]\r\n    }\r\n});\r\n```\r\n\r\n`__set__` returns a function which reverts the changes introduced by this particular `__set__` call\r\n\r\n```javascript\r\nvar revert = myModule.__set__(\"port\", 3000);\r\n\r\n// port is now 3000\r\nrevert();\r\n// port is now the previous value\r\n```\r\n\r\nFor your convenience you can also use the `__with__` method which reverts the given changes after it finished.\r\n\r\n```javascript\r\nmyModule.__with__({\r\n    port: 3000\r\n})(function () {\r\n    // within this function port is 3000\r\n});\r\n// now port is the previous value again\r\n```\r\n\r\nThe `__with__` method is also aware of promises. If a thenable is returned all changes stay until the promise has either been resolved or rejected.\r\n\r\n```javascript\r\nmyModule.__with__({\r\n    port: 3000\r\n})(function () {\r\n    return new Promise(...);\r\n}).then(function () {\r\n    // now port is the previous value again\r\n});\r\n// port is still 3000 here because the promise hasn't been resolved yet\r\n```\r\n\r\n<br />\r\n\r\nLimitations\r\n-----------\r\n\r\n**Babel's ES module emulation**<br>\r\nDuring the transpilation step from ESM to CJS modules, Babel renames internal variables. Rewire will not work in these cases (see [#62](https://github.com/jhnns/rewire/issues/62)). Other Babel transforms, however, should be fine. Another solution might be switching to [babel-plugin-rewire](https://github.com/speedskater/babel-plugin-rewire).\r\n\r\n**Variables inside functions**<br>\r\nVariables inside functions can not be changed by rewire. This is constrained by the language.\r\n\r\n```javascript\r\n// myModule.js\r\n(function () {\r\n    // Can't be changed by rewire\r\n    var someVariable;\r\n})()\r\n```\r\n\r\n**Modules that export primitives**<br>\r\nrewire is not able to attach the `__set__`- and `__get__`-method if your module is just exporting a primitive. Rewiring does not work in this case.\r\n\r\n```javascript\r\n// Will throw an error if it's loaded with rewire()\r\nmodule.exports = 2;\r\n```\r\n\r\n**Globals with invalid variable names**<br>\r\nrewire imports global variables into the local scope by prepending a list of `var` declarations:\r\n\r\n```javascript\r\nvar someGlobalVar = global.someGlobalVar;\r\n```\r\n\r\nIf `someGlobalVar` is not a valid variable name, rewire just ignores it. **In this case you're not able to override the global variable locally**.\r\n\r\n**Special globals**<br>\r\nPlease be aware that you can't rewire `eval()` or the global object itself.\r\n\r\n\r\n<br />\r\n\r\nAPI\r\n---\r\n\r\n### rewire(filename: String): rewiredModule\r\n\r\nReturns a rewired version of the module found at `filename`. Use `rewire()` exactly like `require()`.\r\n\r\n### rewiredModule.&#95;&#95;set&#95;&#95;(name: String, value: *): Function\r\n\r\nSets the internal variable `name` to the given `value`. Returns a function which can be called to revert the change.\r\n\r\n### rewiredModule.&#95;&#95;set&#95;&#95;(obj: Object): Function\r\n\r\nTakes all enumerable keys of `obj` as variable names and sets the values respectively. Returns a function which can be called to revert the change.\r\n\r\n### rewiredModule.&#95;&#95;get&#95;&#95;(name: String): *\r\n\r\nReturns the private variable with the given `name`.\r\n\r\n### rewiredModule.&#95;&#95;with&#95;&#95;(obj: Object): Function&lt;callback: Function>\r\n\r\nReturns a function which - when being called - sets `obj`, executes the given `callback` and reverts `obj`. If `callback` returns a promise, `obj` is only reverted after the promise has been resolved or rejected. For your convenience the returned function passes the received promise through.\r\n\r\n<br />\r\n\r\nCaveats\r\n-------\r\n\r\n**Difference to require()**<br>\r\nEvery call of rewire() executes the module again and returns a fresh instance.\r\n\r\n```javascript\r\nrewire(\"./myModule.js\") === rewire(\"./myModule.js\"); // = false\r\n```\r\n\r\nThis can especially be a problem if the module is not idempotent [like mongoose models](https://github.com/jhnns/rewire/issues/27).\r\n\r\n**Globals are imported into the module's scope at the time of rewiring**<br>\r\nSince rewire imports all gobals into the module's scope at the time of rewiring, property changes on the `global` object after that are not recognized anymore. This is a [problem when using sinon's fake timers *after* you've called `rewire()`](http://stackoverflow.com/questions/34885024/when-using-rewire-and-sinon-faketimer-order-matters/36025128).\r\n\r\n**Dot notation**<br>\r\nAlthough it is possible to use dot notation when calling `__set__`, it is strongly discouraged in most cases. For instance, writing `myModule.__set__(\"console.log\", fn)` is effectively the same as just writing `console.log = fn`. It would be better to write:\r\n\r\n```javascript\r\nmyModule.__set__(\"console\", {\r\n    log: function () {}\r\n});\r\n```\r\n\r\nThis replaces `console` just inside `myModule`. That is, because rewire is using `eval()` to turn the key expression into an assignment. Hence, calling `myModule.__set__(\"console.log\", fn)` modifies the `log` function on the *global* `console` object.\r\n\r\n<br />\r\n\r\nwebpack\r\n-------\r\nSee [rewire-webpack](https://github.com/jhnns/rewire-webpack)\r\n\r\n<br />\r\n\r\nCoffeeScript\r\n------------\r\n\r\nGood news to all caffeine-addicts: rewire works also with [Coffee-Script](http://coffeescript.org/). Note that in this case CoffeeScript needs to be listed in your devDependencies.\r\n\r\n<br />\r\n\r\n## License\r\n\r\nMIT\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/jhnns/rewire.git"
  },
  "scripts": {
    "coverage": "istanbul cover ./node_modules/mocha/bin/_mocha",
    "test": "mocha -R spec"
  },
  "version": "3.0.2"
}
